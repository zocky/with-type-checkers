export const AsyncFunction = (async () => { }).constructor;
export const defaultTypeCheckers = {
  any: v => true,
  object: v => typeof v === 'object' && v !== null && !Array.isArray(v),
  plainObject: v => Object.prototype.toString.call(v) === '[object Object]',
  string: v => typeof v === 'string',
  number: v => typeof v === 'number' && !isNaN(v),
  positive: v => typeof v === 'number' && v > 0,
  negative: v => typeof v === 'number' && v < 0,
  integer: v => typeof v === 'number' && v % 1 === 0,
  positiveInteger: v => typeof v === 'number' && v > 0 && v % 1 === 0,
  negativeInteger: v => typeof v === 'number' && v < 0 && v % 1 === 0,
  boolean: v => typeof v === 'boolean',
  function: v => typeof v === 'function',
  array: v => Array.isArray(v),
  null: v => v === null,
  undefined: v => typeof v === 'undefined',
  none: v => v === null || typeof v === 'undefined',
  symbol: v => typeof v === 'symbol',
  bigint: v => typeof v === 'bigint',
  date: v => v instanceof Date && !isNaN(v),
  regexp: v => v instanceof RegExp,
  error: v => v instanceof Error,
  promise: v => v instanceof Promise || (v && typeof v.then === 'function' && typeof v.catch === 'function'),
  set: v => v instanceof Set,
  map: v => v instanceof Map,
  weakset: v => v instanceof WeakSet,
  weakmap: v => v instanceof WeakMap,
  iterable: v => typeof v === 'object' && v !== null && typeof v[Symbol.iterator] === 'function',
  numeric: v => !isNaN(parseFloat(v)) && isFinite(v),
  emptyString: v => typeof v === 'string' && v.length === 0,
  notEmptyString: v => typeof v === 'string' && v.length > 0,
  emptyArray: v => Array.isArray(v) && v.length === 0,
  notEmptyArray: v => Array.isArray(v) && v.length > 0,
  falsy: v => !v,
  truthy: v => !!v,
  primitive: v => v === null || (typeof v !== 'object' && typeof v !== 'function'),
  asyncFunction: v => typeof v === 'function' && v instanceof AsyncFunction,
  syncFunction: v => typeof v === 'function' && !(v instanceof AsyncFunction),
};
